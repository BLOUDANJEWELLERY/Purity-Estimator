<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Gold Purity Estimator (Camera-Based)</title>
  <script async src="https://docs.opencv.org/4.x/opencv.js"></script>
  <style>
    body {
      background-color: #1a1a1a;
      color: #fff;
      font-family: Arial, sans-serif;
      padding: 20px;
    }
    .container {
      max-width: 900px;
      margin: auto;
      background-color: #2c2c2c;
      padding: 20px;
      border-radius: 10px;
    }
    h1, h2 {
      color: #c7a332;
      text-align: center;
    }
    input, select, button {
      width: 100%;
      padding: 10px;
      margin-top: 10px;
      border-radius: 5px;
      border: none;
      background-color: #3c3c3c;
      color: white;
    }
    button {
      background-color: #c7a332;
      cursor: pointer;
    }
    canvas {
      margin-top: 15px;
      max-width: 100%;
    }
    .result-box {
      background-color: #444;
      padding: 15px;
      border-radius: 5px;
      margin-top: 15px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Gold Purity Estimator (Option B)</h1>

    <label>Upload Image (Top-Down with 100 Fils Coin):</label>
    <input type="file" accept="image/*" onchange="handleImage(event)">

    <label>Dry Weight of Gold (g):</label>
    <input type="number" id="dryWeight" step="any">

    <label>Gold Shape:</label>
    <select id="shape">
      <option value="rod">Rod/Cylinder</option>
      <option value="bar">Bar/Block</option>
      <option value="coin">Coin</option>
      <option value="irregular">Irregular/Nugget</option>
    </select>

    <button onclick="calculateFromImage()">Estimate Purity</button>
    <button onclick="reset()">Retake Photo</button>

    <canvas id="canvas"></canvas>
    <div class="result-box" id="resultBox"></div>
  </div>

  <script>
    let src = null, imgElement = null;

    function handleImage(event) {
      const file = event.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(e) {
        imgElement = new Image();
        imgElement.onload = function() {
          const canvas = document.getElementById("canvas");
          const ctx = canvas.getContext("2d");
          canvas.width = imgElement.width;
          canvas.height = imgElement.height;
          ctx.drawImage(imgElement, 0, 0);
        };
        imgElement.src = e.target.result;
      };
      reader.readAsDataURL(file);
    }

    function reset() {
      document.getElementById("canvas").getContext("2d").clearRect(0, 0, 10000, 10000);
      document.getElementById("resultBox").innerHTML = "";
      document.querySelector("input[type='file']").value = "";
    }

    async function calculateFromImage() {
      const dryWeight = parseFloat(document.getElementById("dryWeight").value);
      if (isNaN(dryWeight)) {
        alert("Enter dry weight.");
        return;
      }

      const canvas = document.getElementById("canvas");
      if (!canvas.width) {
        alert("Please upload an image.");
        return;
      }

      if (!cv || !cv.imread) {
        alert("OpenCV.js not yet loaded.");
        return;
      }

      const mat = cv.imread(canvas);
      let gray = new cv.Mat();
      cv.cvtColor(mat, gray, cv.COLOR_RGBA2GRAY, 0);
      cv.GaussianBlur(gray, gray, new cv.Size(5, 5), 0, 0, cv.BORDER_DEFAULT);
      cv.threshold(gray, gray, 60, 255, cv.THRESH_BINARY);

      // Detect contours
      let contours = new cv.MatVector();
      let hierarchy = new cv.Mat();
      cv.findContours(gray, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

      let coinDiameterPx = null;
      let goldAreaPx = 0;

      for (let i = 0; i < contours.size(); i++) {
        let cnt = contours.get(i);
        let area = cv.contourArea(cnt);
        let perimeter = cv.arcLength(cnt, true);
        let circularity = 4 * Math.PI * area / (perimeter * perimeter);

        if (area > 100 && circularity > 0.7 && circularity < 1.2) {
          // Coin found
          let rect = cv.boundingRect(cnt);
          coinDiameterPx = (rect.width + rect.height) / 2;
        } else if (area > goldAreaPx) {
          goldAreaPx = area; // assume largest other object = gold
        }
        cnt.delete();
      }

      gray.delete(); hierarchy.delete(); contours.delete();

      if (!coinDiameterPx || goldAreaPx === 0) {
        document.getElementById("resultBox").innerHTML = "Reference coin not detected or gold object missing.";
        mat.delete();
        return;
      }

      // Scale area to real world
      const coinDiameterMm = 26.0;
      const pixelToMm = coinDiameterMm / coinDiameterPx;
      const goldAreaMm2 = goldAreaPx * (pixelToMm ** 2);

      // Estimate height from shape
      const shape = document.getElementById("shape").value;
      let heightMm = 1.5; // default
      if (shape === "rod") heightMm = 15;
      else if (shape === "bar") heightMm = 10;
      else if (shape === "coin") heightMm = 1.5;
      else if (shape === "irregular") heightMm = 8;

      const volumeCm3 = (goldAreaMm2 * heightMm) / 1000; // mm³ to cm³
      const density = dryWeight / volumeCm3;
      const goldDensity = 19.3;
      const purity = Math.round((density / goldDensity) * 1000);

      document.getElementById("resultBox").innerHTML = `
        <b>Detected Area:</b> ${goldAreaMm2.toFixed(2)} mm²<br>
        <b>Assumed Height:</b> ${heightMm} mm<br>
        <b>Volume:</b> ${volumeCm3.toFixed(2)} cm³<br>
        <b>Density:</b> ${density.toFixed(2)} g/cm³<br>
        <b>Estimated Purity:</b> ${Math.min(purity, 1000)} / 1000
      `;

      mat.delete();
    }
  </script>
</body>
</html>